---
import 'prismjs/themes/prism-coy.min.css';
import '../_shared/entryContents.css';

import { getCollection, render } from 'astro:content';
import { parse } from 'valibot';

import { pathList } from '../../../constants/pathList';
import { OG_IMAGE_PATH, SITE_URL } from '../../../constants/siteData';
import PublicationMetadata from '../../features/entry/components/PublicationMetadata.astro';
import Taxonomy from '../../features/entry/components/Taxonomy.astro';
import { formatIsoString } from '../../features/entry/date';
import { likesResponseSchema } from '../../features/likes/api/likesApiValidationSchema';
import { LikeButton } from '../../features/likes/components/LikeButton';
import { retrieveTranslation } from '../../features/locales/i18n';
import { createBlogPostingStructuredData } from '../../features/structured_data/blogPostingStructuredData';
import Body from '../../layouts/Body.astro';
import GlobalFooter from '../../layouts/GlobalFooter.astro';
import GlobalHeader from '../../layouts/GlobalHeader.astro';
import Head from '../../layouts/Head.astro';
import Html from '../../layouts/Html.astro';
import Main from '../../layouts/Main.astro';

export async function getStaticPaths() {
  const entries = await getCollection('entries');

  return entries.map((entry) => ({
    params: { id: entry.id },
    props: { entry },
  }));
}

const { entry } = Astro.props;
const { id } = entry;
const { Content } = await render(entry);
const { title: entryTitle, excerpt, tags = [], publishedAt, revisedAt } = entry.data;
const url = `${SITE_URL}/${pathList.entries}/${id}`;
const ogImageUrl = `${OG_IMAGE_PATH}/${id}.png`;

const publishedDateString = formatIsoString(publishedAt);
const revisedDateString = formatIsoString(revisedAt ?? publishedAt);

const structuredData = JSON.stringify(
  createBlogPostingStructuredData({
    title: entryTitle,
    content: excerpt ?? '',
    publishedDateString,
    revisedDateString,
  }),
);

let counts = 0;

const urlString = `${Astro.url.origin}/api/likes/${id}`;

try {
  const response = await fetch(urlString);

  if (response.ok) {
    const data = await response.json();
    const validatedData = parse(likesResponseSchema, data);
    counts = validatedData.counts;
  }
} catch (error) {
  console.error('Failed to fetch like count:', error);
}
---

<style>
  article {
    position: relative;
  }

  article > footer {
    margin-top: var(--space-component-4);
  }

  .PublicationMetadata {
    margin-top: var(--space-component-2);
  }

  .Contents {
    margin-top: var(--space-component-4);
  }

  article > aside {
    display: flex;
    align-items: start;
    justify-content: center;
    margin-top: var(--space-component-4);
  }

  .Like {
    height: fit-content;
  }

  @media (min-width: 992px) {
    article > aside {
      position: absolute;
      top: 0;
      left: calc(var(--font-size-text) * -6 - var(--space-component-2));
      width: calc(var(--font-size-text) * 6);
      height: 100%;
      margin-top: 0;
    }

    .Like {
      position: sticky;
      top: var(--space-component-4);
    }
  }
</style>

<Html>
  <Head title={entryTitle} description={excerpt ?? ''} pageType="article" pageUrl={url} ogImageUrl={ogImageUrl}>
    <script type="application/ld+json" is:inline set:html={structuredData} />
  </Head>
  <Body>
    <GlobalHeader hasHeadings={false} />
    <Main>
      <article>
        <header>
          <h1>{entryTitle}</h1>
          <div class="PublicationMetadata">
            <PublicationMetadata publishedAt={publishedAt} revisedAt={revisedAt} />
          </div>
        </header>
        <div class="Contents">
          <Content />
        </div>
        <footer>
          {tags.length > 0 && <Taxonomy tags={tags} />}
        </footer>
        <aside>
          <div class="Like">
            <LikeButton
              client:visible
              counts={counts}
              entryId={id}
              likeLabel={retrieveTranslation('entry.action.like')}
            />
          </div>
        </aside>
      </article>
    </Main>
    <GlobalFooter />
  </Body>
</Html>
