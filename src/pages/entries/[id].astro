---
import 'prismjs/themes/prism-coy.min.css';
import '../_shared/entryContents.css';

import { getCollection, render } from 'astro:content';
import { parse } from 'valibot';

import { pathList } from '../../../constants/pathList';
import { formatIsoString, formatYYMDString } from '../../features/entry/date';
import { likesResponseSchema } from '../../features/likes/api/likesApiValidationSchema';
import { LikeButton } from '../../features/likes/components/LikeButton';
import { retrieveTranslation } from '../../features/locales/i18n';
import { createBlogPostingStructuredData } from '../../features/structured_data/blogPostingStructuredData';
import EntryShell from '../_layouts/EntryShell.astro';

export async function getStaticPaths() {
  const entries = await getCollection('entries');

  return entries.map((entry) => ({
    params: { id: entry.id },
    props: { entry },
  }));
}

const { entry } = Astro.props;
const { id } = entry;
const { Content } = await render(entry);
const { title: entryTitle, excerpt, categories = [], tags = [], publishedAt, revisedAt } = entry.data;

const publishedDateString = formatIsoString(publishedAt);
const revisedDateString = formatIsoString(revisedAt ?? publishedAt);

const structuredData = JSON.stringify(
  createBlogPostingStructuredData({
    title: entryTitle,
    content: excerpt ?? '',
    publishedDateString,
    revisedDateString,
  }),
);

let counts = 0;

const urlString = `${Astro.url.origin}/api/likes/${id}`;

try {
  const response = await fetch(urlString);

  if (response.ok) {
    const data = await response.json();
    const validatedData = parse(likesResponseSchema, data);
    counts = validatedData.counts;
  }
} catch (error) {
  console.error('Failed to fetch like count:', error);
}
---

<style>
  article > header::after {
    content: '';
    display: block;
    width: var(--border-width-entry-header);
    height: var(--border-size);
    margin-top: var(--space-component-1);
    background-color: var(--color-main);
  }

  .PublishedDate {
    display: block;
    font-size: var(--font-size-note);
  }

  .Contents {
    margin-top: var(--space-component-4);
  }

  article > footer {
    margin-top: var(--space-component-4);
  }

  .EntryMetadataListContainer {
  }

  .EntryMetadataListContainer::after {
    content: '';
    display: block;
    width: var(--border-width-entry-footer);
    height: var(--border-size);
    margin-top: var(--space-component-1);
    background-color: var(--color-main);
  }

  .EntryMetadataList {
    display: flex;
    flex-wrap: wrap;
    margin: 0;
  }

  .EntryMetadataList > dd {
    display: flex;
    margin-left: var(--space-component-1);
  }

  .Like {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: var(--space-component-4);
  }
</style>

<EntryShell title={entryTitle} description={excerpt ?? ''} slug={id}>
  <article>
    <header>
      <time class="PublishedDate" datetime={publishedDateString}>
        {formatYYMDString(publishedAt, { year: '年', month: '月', day: '日' })}
      </time>
      <h1>{entryTitle}</h1>
    </header>
    <div class="Contents">
      <Content />
    </div>
    <footer>
      {
        (categories.length > 0 || tags.length > 0) && (
          <div class="EntryMetadataListContainer">
            {categories.length > 0 && (
              <dl class="EntryMetadataList">
                <dt>{retrieveTranslation('categories.text')}</dt>
                {categories.map((category) => (
                  <dd>
                        <a href={`/${pathList.categories}/${category}`}>{category}</a>
                  </dd>
                ))}
              </dl>
            )}
            {tags.length > 0 && (
              <dl class="EntryMetadataList">
                <dt>{retrieveTranslation('tags.text')}</dt>
                {tags.map((tag) => (
                  <dd>
                        <a href={`/${pathList.tags}/${tag}`}>{tag}</a>
                  </dd>
                ))}
              </dl>
            )}
          </div>
        )
      }
      <div class="Like">
        <LikeButton client:visible counts={counts} entryId={id} likeLabel={retrieveTranslation('entry.action.like')} />
      </div>
    </footer>
  </article>
  <script type="application/ld+json" is:inline set:html={structuredData} />
</EntryShell>
